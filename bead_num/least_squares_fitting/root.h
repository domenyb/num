#include "bases.h"
#include <math.h>

double buildingvector_norm(matrix* m, int number_of_vector){
  double eredm;
  for (int i=0;i<m->rows;i++){
    eredm+=(extr_matrix_value(m, number_of_vector, i)*extr_matrix_value(m, number_of_vector, i));
  }
  return sqrt(eredm);
}



matrix*  qr_gs_inverse( matrix* Q, matrix* R){
    matrix* Qt=transpose(Q);
    matrix* Rt=invert_upper_triangular(R);
    matrix * object=matrix_multiplication(Rt, Qt);
    matrix_free(Qt);
    matrix_free(Rt);
    return object;
}

matrix * GramSchmidt (matrix* original){
  matrix * R = matrix_alloc(original->cols, original->cols);
  double* buffer_vector=malloc(sizeof(double)*original->rows);
  for (int i=0;i<original->cols;i++){
      for (int j=0;j<original->rows;j++){
          buffer_vector[j]=extr_matrix_value(original, i, j);//this is the ai "vector", the i. column of the A matrix
      }
    /*  if (i==0){
          for (int l=0;l<original->rows;l++){
              printf("buffer_vector %g \n", buffer_vector[l] );
          }
      }*/
      double Rii=buildingvector_norm(original,i);//i need this multiple times, so don't really want to calculate it separately
      add_matrix_value(R,i,i,Rii);
      for (int j=0;j<original->rows;j++){
          buffer_vector[j]/=Rii;//normalisation of the vector
          add_matrix_value(original, i, j, buffer_vector[j]);
      }
      for (int j=i+1;j<original->cols;j++){
          double Rij=0;
          for (int k=0;k<original->rows;k++){
              Rij+=extr_matrix_value(original, j, k)*buffer_vector[k];//this is the aj "vector", the j. column of the A matrix
        }
          add_matrix_value(R,j,i,Rij);
          add_matrix_value(R,i,j, 0);
    //      print_matrix(R);
          for (int k=0;k<original->rows;k++){
              double new_val=extr_matrix_value(original, j, k);
              new_val-=buffer_vector[k]*Rij;
              add_matrix_value(original, j, k, new_val);//this is the aj "vector", the j. column of the A matrix
          }
      }
  }
  return R;
}

vector*  qr_gs_solve(matrix* Q, matrix* R, vector* b){
  matrix* Qt=transpose(Q);
  vector* object=matrix_vector_appl(Qt, b);
  for (int i=b->n-1;i>-1;i--){
//    printf("Rx(%d) %lg\n",i,object->data[i] );
    double buffer=0;
    for (int j=i+1;j<b->n;j++){
      buffer+=extr_matrix_value(R, j, i)*object->data[j];
//      printf("Buffer: %lg\n", buffer );
    }
    object->data[i]=(object->data[i]-buffer)/extr_matrix_value(R, i,i);
//    printf("Rx(%d) now:%lg\n",i,object->data[i] );
  }
  matrix_free(Qt);
  return object;
}

double funs(int i, double x){
   switch(i){
   case 0: return log(x); break;
   case 1: return 1.0;   break;
   case 2: return x;     break;
   default: {fprintf(stderr,"funs: wrong i:%d",i); return NAN;}
   }
}

vector* least_squares_fit(double funs(int i, double x), int free_par, vector* x_data, vector* y_data, vector* dy_data, matrix* covariance) {
  int n=x_data->n;

  matrix* A = matrix_alloc(n,free_par);
  vector* b = vector_alloc(n);
  matrix* I = matrix_alloc(free_par, free_par); //identity matrix generated by default

  for (int i=0;i<n;i++){
    b->data[i]=y_data->data[i]/dy_data->data[i];
    for(int k=0;k<free_par;k++){
      add_matrix_value(A, k, i, funs(k, x_data->data[i])/dy_data->data[i]);
    }
  }
  matrix* R=GramSchmidt(A);
  //now A is Q
  vector* sol=qr_gs_solve(A,R,b);//solution vector - the three coefficients
  //covariance matrix? cov=R inverse* R inverse^transpose
  //for that, I'll need the inverse of R, which we fortunately do have
  //R is an upper triangular matrix, and we have an "invert upper triangular matrix" function from back at the Gram Schmidt excersise
  matrix* R_inverse=invert_upper_triangular(R);
  matrix* RiT=transpose(R_inverse);
  //here comes the problem, that all my funcs are not void, looking back that would've been more fortunate.
  matrix* covariance_mtx=matrix_multiplication( R_inverse,RiT);
  mimic_mtrx(covariance_mtx, covariance);
  //free everything
  matrix_free(A);
  matrix_free(I);
  matrix_free(R);
  matrix_free(R_inverse);
  matrix_free(RiT);
  matrix_free(covariance_mtx);
  vector_free(b);
  return sol;
}
